<!-- libs (fresh copy, cache-busted) -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.3/papaparse.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js?v=1"></script>

<script>
  const CM = 28.3464567, cm = v => v * CM;

  const log   = msg => console.log('[PDF-gen]', msg);
  const error = msg => console.error('[PDF-gen]', msg);

  /* -------- main form ------------ */
  const form   = document.getElementById('generatorForm');
  const btn    = document.getElementById('generateBtn');
  const link   = document.getElementById('downloadLink');
  const notice = document.createElement('span');
  notice.className = 'text-sm text-gray-500 ml-2';
  btn.after(notice);

  form.addEventListener('submit', async ev => {
    ev.preventDefault();
    btn.disabled = true; notice.textContent = 'Generatingâ€¦';

    try {
      /* --- read UI --- */
      const val = id => document.getElementById(id).value.trim();
      const ward   = val('groupName');
      const pdfName= (val('pdfName').replace(/\\.pdf$/i,'') || 'name_cards') + '.pdf';

      const pageW=+val('pageW'), pageH=+val('pageH');
      const cardW=+val('cardW'), cardH=+val('cardH');
      const fMax =+val('fontMax'), fMin=+val('fontMin'), fSmall=+val('fontSmall');

      /* --- CSV --- */
      const file = document.getElementById('csvInput').files[0];
      if (!file) throw new Error('No CSV file chosen.');

      const rows = await new Promise(res => {
        Papa.parse(file, { skipEmptyLines:true, complete:r=>res(r.data) });
      });
      const roster = rows.map(r => ({ first:(r[1]||'').trim(), last:(r[0]||'').trim() }))
                         .filter(n => n.first && n.last);
      if (!roster.length) throw new Error('CSV seems empty or badly-formatted.');

      /* --- PDF build --- */
      const { PDFDocument, rgb, StandardFonts } = PDFLib;
      const pdf   = await PDFDocument.create();
      const font  = await pdf.embedFont(StandardFonts.Helvetica);
      const bold  = await pdf.embedFont(StandardFonts.HelveticaBold);

      const pW=cm(pageW), pH=cm(pageH), cW=cm(cardW), cH=cm(cardH);
      const cols=2, rows=2, per=cols*rows;

      const fit = (text,max)=>{          // quick inline autosize
        let s=fMax; while(s>=fMin && bold.widthOfTextAtSize(text,s)>max) s--; return s;
      };

      roster.forEach((n,i)=>{
        if(i%per===0) pdf.addPage([pW,pH]);
        const pg = pdf.getPage(pdf.getPageCount()-1);
        const pos=i%per, col=pos%cols, row=Math.floor(pos/cols);
        const ox=col*cW, oy=pH-(row+1)*cH;

        pg.drawRectangle({x:ox,y:oy,width:cW,height:cH,borderWidth:1.5,
                          borderColor:rgb(0,0,0),borderDashArray:[4,3],
                          color:rgb(1,1,1),opacity:0});

        pg.drawText(ward,{x:ox+cm(0.5),y:oy+cH-cm(0.5)-10,size:10,font});

        const size=fit(n.first,cm(cardW-2));
        pg.drawText(n.first,{
          x:ox+cW/2-bold.widthOfTextAtSize(n.first,size)/2,
          y:oy+cH/1.7-size/2,size,font:bold});
        const full=`${n.first} ${n.last}`;
        pg.drawText(full,{
          x:ox+cW/2-font.widthOfTextAtSize(full,fSmall)/2,
          y:oy+cH/4-fSmall/2,size:fSmall,font});
      });

      /* --- download --- */
      const blob=new Blob([await pdf.save()],{type:'application/pdf'});
      link.href=URL.createObjectURL(blob);
      link.download=pdfName;
      link.textContent='Download '+pdfName;
      link.classList.remove('hidden');

      /* attempt auto-click; if blocked, user still sees link */
      setTimeout(()=>{ try{ link.click(); }catch(e){ log('Auto-click blocked'); }},10);

      notice.textContent=' PDF ready!';
    }
    catch(e){
      error(e);
      alert('Failed: '+e.message);
      notice.textContent='';
    }
    finally{ btn.disabled=false; }
  });
</script>
